<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ADL (AMD Display Library) Public APIs: DDCBlockAccess/DDCBlockAccessDlg.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>DDCBlockAccess/DDCBlockAccessDlg.cpp</h1>A C/C++ Sample Application for Windows (XP, Vista and above); 32bit and 64bit <br>
 Visual Studio 2005 solution file <b> "DDCBlockAccess.sln" </b> is included in ADL SDK<p>
<div class="fragment"><pre class="fragment"><span class="comment">// DDCBlockAccessDlg.cpp : implementation file</span>
<span class="comment">//</span>

<span class="preprocessor">#include "stdafx.h"</span>
<span class="preprocessor">#include &lt;codecvt&gt;</span>
<span class="preprocessor">#include "..\..\include\adl_sdk.h"</span>
<span class="preprocessor">#include "DDCBlockAccess.h"</span>
<span class="preprocessor">#include "DDCBlockAccessDlg.h"</span>
<span class="preprocessor">#include "mccs.h"</span>

<span class="preprocessor">#ifdef _DEBUG</span>
<span class="preprocessor"></span><span class="preprocessor">#define new DEBUG_NEW</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="comment">//********************************</span>
<span class="comment">// Prototypes</span>
<span class="comment">//********************************</span>
<span class="keywordtype">void</span>    vGetVcpCommand(UCHAR ucVcp, UINT * ulMaxVal, UINT * ulCurVal, <span class="keywordtype">int</span> iAdapterIndex, <span class="keywordtype">int</span> iDisplayIndex);
<span class="keywordtype">void</span>    vSetVcpCommand(UCHAR ucVcp, UINT ulVal, <span class="keywordtype">int</span> iAdapterIndex, <span class="keywordtype">int</span> iDisplayIndex);
<span class="keywordtype">bool</span>    vGetCapabilitiesCommand(UCHAR ucVcp, <span class="keywordtype">int</span> iAdapterIndex, <span class="keywordtype">int</span> iDisplayIndex);
<span class="keywordtype">int</span>             vWriteI2c(<span class="keywordtype">char</span> * lpucSendMsgBuf, <span class="keywordtype">int</span> iSendMsgLen, <span class="keywordtype">int</span> iAdapterIndex, <span class="keywordtype">int</span> iDisplayIndex);
<span class="keywordtype">int</span>             vWriteAndReadI2c(<span class="keywordtype">char</span> *lpucSendMsgBuf, <span class="keywordtype">int</span> iSendMsgLen, <span class="keywordtype">char</span> * lpucRecvMsgBuf, <span class="keywordtype">int</span> iRecvMsgLen,  <span class="keywordtype">int</span> iAdapterIndex, <span class="keywordtype">int</span> iDisplayIndex);
<span class="keywordtype">bool</span>    InitADL();
<span class="keywordtype">void</span>    FreeADL();


<span class="keywordtype">void</span>* <a name="a0"></a><a class="code" href="adl__sdk_8h.html#d16f14718feefaa629b3b7601ac9fdeb">__stdcall</a> ADL_Main_Memory_Alloc ( <span class="keywordtype">int</span> iSize )
{
    <span class="keywordtype">void</span>* lpBuffer = malloc ( iSize );
    <span class="keywordflow">return</span> lpBuffer;
}

<span class="keywordtype">void</span> <a class="code" href="adl__sdk_8h.html#d16f14718feefaa629b3b7601ac9fdeb">__stdcall</a> ADL_Main_Memory_Free ( <span class="keywordtype">void</span>** lpBuffer )
{
    <span class="keywordflow">if</span> ( NULL != *lpBuffer )
    {
        free ( *lpBuffer );
        *lpBuffer = NULL;
    }
}

<span class="comment">//********************************</span>
<span class="comment">// Globals</span>
<span class="comment">//********************************</span>
UINT aAllConnectedDisplays[MAX_NUM_DISPLAY_DEVICES]; <span class="comment">//int array of connected displays for each of the ATI devices (aligned with sDriverNames)</span>
ADLPROCS adlprocs = {0,0,0,0};
UCHAR ucSetCommandWrite[SETWRITESIZE]           =                                               {0x6e,0x51,0x84,0x03,0x00,0x00,0x00,0x00};
UCHAR ucGetCommandRequestWrite[GETRQWRITESIZE]  =               {0x6e,0x51,0x82,0x01,0x00,0x00};
UCHAR ucGetCommandCapabilitiesWrite[GETCAPWRITESIZE]={0x6e,0x51,0x83,0xf3,0x00,0x00,0x00};
UCHAR ucGetCommandReplyWrite[GETREPLYWRITESIZE] =               {0x6f};
UCHAR ucGetCommandReplyRead[MAXREADSIZE];
UCHAR ucGlobalVcp = VCP_CODE_BRIGHTNESS;

<a name="_a1"></a><a class="code" href="structAdapterInfo.html" title="Structure containing information about the graphics adapter.">LPAdapterInfo</a>                   lpAdapterInfo = NULL;
<a name="_a2"></a><a class="code" href="structADLDisplayInfo.html" title="Structure containing information about the display device.">LPADLDisplayInfo</a>        lpAdlDisplayInfo = NULL;
<span class="keywordtype">char</span>                                                    MonitorNames[MAX_NUM_DISPLAY_DEVICES] [128];            <span class="comment">// Array of Monitor names</span>


<span class="comment">//********************************</span>
<span class="comment">// Helper Functions</span>
<span class="comment">//********************************</span>

<span class="comment">//****************************************************************************</span>
<span class="comment">//</span>
<span class="comment">//  int iInitDisplayNames()</span>
<span class="comment">//</span>
<span class="comment">//  This function initializes the display name buffers passed in the </span>
<span class="comment">//  parameter list as an array of CStrings </span>
<span class="comment">//</span>
<span class="comment">//  Returns: The function will return the number of connected adapters.</span>
<span class="comment">//           So if only one adapter/driver is loaded, this will return 1.</span>
<span class="comment">//</span>
<span class="comment">//****************************************************************************/</span>
<span class="keywordtype">int</span> iInitDisplayNames(CString *aDriverNames)
{
  <span class="keywordtype">int</span>                   iNumberAdapters = 0;
  <span class="keywordtype">int</span>                   iAdapterIndex;
  <span class="keywordtype">int</span>                   iDisplayIndex;
  <span class="keywordtype">int</span>                   iNumDisplays;
  <span class="keywordtype">int</span>                   ADL_Err = <a name="a3"></a><a class="code" href="group__define__adl__results.html#g917345ca58ec6b4d7c73865fdb611fd7" title="Generic Error. Most likely one or more of the Escape calls to the driver failed!">ADL_ERR</a>;

                adlprocs.ADL_Adapter_NumberOfAdapters_Get ( &amp;iNumberAdapters );

        <span class="keywordflow">if</span> ( 0 &gt;=  iNumberAdapters )            <span class="comment">// No adapters found!!!</span>
                        <span class="keywordflow">return</span> 0;

        lpAdapterInfo = (<a class="code" href="structAdapterInfo.html" title="Structure containing information about the graphics adapter.">LPAdapterInfo</a>)malloc ( <span class="keyword">sizeof</span> (<a class="code" href="structAdapterInfo.html" title="Structure containing information about the graphics adapter.">AdapterInfo</a>) * iNumberAdapters );
        memset ( lpAdapterInfo,<span class="charliteral">'\0'</span>, <span class="keyword">sizeof</span> (<a class="code" href="structAdapterInfo.html" title="Structure containing information about the graphics adapter.">AdapterInfo</a>) * iNumberAdapters );

        <span class="comment">// Get the AdapterInfo structure for all adapters in the system</span>
        adlprocs.ADL_Adapter_AdapterInfo_Get (lpAdapterInfo, <span class="keyword">sizeof</span> (<a class="code" href="structAdapterInfo.html" title="Structure containing information about the graphics adapter.">AdapterInfo</a>) * iNumberAdapters);

                <span class="comment">// Repeat for all available adapters in the system</span>
                <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; iNumberAdapters; i++ )
                {
                        iAdapterIndex = lpAdapterInfo[ i ].<a name="a4"></a><a class="code" href="structAdapterInfo.html#1cebd517a5310383f786a12b71cdd58d" title="The ADL index handle. One GPU may be associated with one or two index handles.">iAdapterIndex</a>;
                        ADL_Main_Memory_Free ( (<span class="keywordtype">void</span> **) &amp;lpAdlDisplayInfo );

                        ADL_Err = adlprocs.ADL_Display_DisplayInfo_Get (lpAdapterInfo[i].iAdapterIndex, &amp;iNumDisplays, &amp;lpAdlDisplayInfo, 0);

                        <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> j = 0; j &lt; iNumDisplays; j++ )
                        {
                                <span class="comment">// For each display, check its status. Use the display only if it's connected AND mapped (iDisplayInfoValue: bit 0 and 1 )</span>
                <span class="keywordflow">if</span> (  ( <a name="a5"></a><a class="code" href="group__define__displayinfomask.html#g3f63aa488171eb7d1b926d62fdab6971">ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED</a> | <a name="a6"></a><a class="code" href="group__define__displayinfomask.html#g6657b7cd9972d66e999c542e02844e9f">ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED</a> ) != 
                                        ( <a class="code" href="group__define__displayinfomask.html#g3f63aa488171eb7d1b926d62fdab6971">ADL_DISPLAY_DISPLAYINFO_DISPLAYCONNECTED</a> | <a class="code" href="group__define__displayinfomask.html#g6657b7cd9972d66e999c542e02844e9f">ADL_DISPLAY_DISPLAYINFO_DISPLAYMAPPED</a>      &amp; lpAdlDisplayInfo[ j ].iDisplayInfoValue ) )
                                        <span class="keywordflow">continue</span>;   <span class="comment">// Skip the not connected or non-active displays</span>

                                <span class="comment">// Is the display mapped to this adapter?</span>
<span class="comment">//                              if ( iAdapterIndex != lpAdlDisplayInfo[ j ].displayID.iDisplayLogicalAdapterIndex )</span>
<span class="comment">//                                      continue;</span>
                                
                                <span class="comment">// Preserve the Connected displays in PDL style :-)</span>
                                iDisplayIndex = lpAdlDisplayInfo[ j ].<a name="a7"></a><a class="code" href="structADLDisplayInfo.html#d5c80e31651a63529680aff4aad8c399" title="The DisplayID structure.">displayID</a>.<a name="a8"></a><a class="code" href="structADLDisplayID.html#c1ab503151ff9ff329dff9701b71c96f" title="The logical display index belonging to this adapter.">iDisplayLogicalIndex</a>;
                                aAllConnectedDisplays[ iAdapterIndex ] |= 1 &lt;&lt; iDisplayIndex;

                                <a name="a9"></a><a class="code" href="secure__crt__linux_8h.html#fb9e900252aa4ece73ad42e4a6db7b95">strncpy_s</a>( MonitorNames[ j ], lpAdlDisplayInfo[ j ].strDisplayName, 127 );
                        }
                        <span class="keywordtype">char</span> tmp[4];
                        sprintf_s( tmp, <span class="stringliteral">"%d"</span>, lpAdapterInfo[ i ].iAdapterIndex );
                        aDriverNames[i] = tmp;
                }
                <span class="keywordflow">return</span> iNumberAdapters;
}

<span class="comment">// Function:</span>
<span class="comment">// void vGetCapabilitiesCommand</span>
<span class="comment">// Purpose:</span>
<span class="comment">// Get the MCCS capabilities</span>
<span class="comment">// Input: UCHAR ucVcp, VCP code (CONTRAST, BRIGHTNESS, etc)</span>
<span class="comment">//        int iDisplayIndex, display index</span>
<span class="comment">// Output: VOID</span>
<span class="keywordtype">bool</span> vGetCapabilitiesCommand(UCHAR ucVcp, <span class="keywordtype">int</span> iAdapterIndex, <span class="keywordtype">int</span> iDisplayIndex)
{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> chk=0;
  <span class="keywordtype">int</span> val=0;
  <span class="keywordtype">int</span> read_val=0;
  <span class="keywordtype">int</span> temp_val=1;
  <span class="keywordtype">int</span> replySize=0;
  <span class="keywordtype">bool</span> ret=TRUE;

  ucGetCommandCapabilitiesWrite[CAP_LOW_OFFSET]=0;

  <span class="keywordflow">if</span> (ucVcp == VCP_CODE_CAPABILITIES)
    replySize = GETREPLYCAPSIZEFIXED;
  <span class="keywordflow">else</span>
    replySize = GETREPLYCAPSIZEVARIABLE;

  <span class="keywordflow">while</span>(temp_val!=0)
  {
    <span class="comment">// set the offset</span>
    ucGetCommandCapabilitiesWrite[CAP_LOW_OFFSET]+=(UCHAR)val;
    <span class="comment">// get checksum</span>
    <span class="keywordflow">for</span> ( i = 0; i &lt; CAP_CHK_OFFSET; i++)
      chk=chk^ucGetCommandCapabilitiesWrite[i];

    ucGetCommandCapabilitiesWrite[CAP_CHK_OFFSET] = chk;

    <span class="comment">// write get capability with offset</span>
    vWriteI2c((<span class="keywordtype">char</span>*)&amp;ucGetCommandCapabilitiesWrite[0], GETCAPWRITESIZE, iAdapterIndex, iDisplayIndex);
    Sleep(40);
    <span class="comment">// initial read to get the length to determine actual read length</span>
    vWriteAndReadI2c((<span class="keywordtype">char</span>*)&amp;ucGetCommandReplyWrite[0], GETREPLYWRITESIZE, (<span class="keywordtype">char</span>*)&amp;ucGetCommandReplyRead[0], replySize,
                     iAdapterIndex, iDisplayIndex);

    <span class="keywordflow">if</span> (ucVcp == VCP_CODE_CAPABILITIES_NEW)
    {
      <span class="comment">// compute read length</span>
      read_val= (int)ucGetCommandReplyRead[GETRP_LENGHTH_OFFSET] &amp; 0x7F;
      read_val += 0x3;
      <span class="comment">// re-write get capability with offset</span>

      vWriteI2c((<span class="keywordtype">char</span>*)&amp;ucGetCommandCapabilitiesWrite[0],GETCAPWRITESIZE, iAdapterIndex, iDisplayIndex);
      Sleep(40);
      <span class="comment">// read with actual read length computed from above</span>
      vWriteAndReadI2c((<span class="keywordtype">char</span>*)&amp;ucGetCommandReplyWrite[0],GETREPLYWRITESIZE,(<span class="keywordtype">char</span>*)&amp;ucGetCommandReplyRead[0],read_val,
                       iAdapterIndex, iDisplayIndex);
    }
    <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)ucGetCommandReplyRead[GETRP_LENGHTH_OFFSET] == 0)
    {
      ret=FALSE;
      <span class="keywordflow">break</span>;
    }
    <span class="comment">// compute new offset</span>
    val=(int)ucGetCommandReplyRead[GETRP_LENGHTH_OFFSET]-0x83;
    temp_val=val;
    chk=0;
  }

  <span class="keywordflow">return</span> ret;
}



<span class="comment">// Function:</span>
<span class="comment">// void vGetVcpCommand</span>
<span class="comment">// Purpose:</span>
<span class="comment">// Get the values from display based on which VCP code</span>
<span class="comment">// Input: UCHAR ucVcp, VCP code (CONTRAST, BRIGHTNESS, etc)</span>
<span class="comment">//        int*ulMaxVal, return value of the max possible value to can be set</span>
<span class="comment">//        int*ulCurVal, return value of current set</span>
<span class="comment">//        int iDisplayIndex, display index</span>
<span class="comment">// Output: VOID</span>

<span class="keywordtype">void</span> vGetVcpCommand(UCHAR ucVcp, UINT * ulMaxVal, UINT * ulCurVal, <span class="keywordtype">int</span> iAdapterIndex, <span class="keywordtype">int</span> iDisplayIndex)
{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> chk=0;
  <span class="keywordtype">int</span> ADL_Err = <a class="code" href="group__define__adl__results.html#g917345ca58ec6b4d7c73865fdb611fd7" title="Generic Error. Most likely one or more of the Escape calls to the driver failed!">ADL_ERR</a>;

  ucGetCommandRequestWrite[GETRQ_VCPCODE_OFFSET]=ucVcp;

  <span class="keywordflow">for</span>( i = 0; i &lt; GETRQ_CHK_OFFSET; i++)
                chk = chk ^ ucGetCommandRequestWrite[ i ];

  ucGetCommandRequestWrite[GETRQ_CHK_OFFSET] = chk;

  ADL_Err = vWriteI2c( (<span class="keywordtype">char</span>*) &amp;ucGetCommandRequestWrite[0], GETRQWRITESIZE, iAdapterIndex, iDisplayIndex);
  Sleep(40);
  ADL_Err = vWriteAndReadI2c( (<span class="keywordtype">char</span>*)&amp;ucGetCommandReplyWrite[0], GETREPLYWRITESIZE, (<span class="keywordtype">char</span>*) &amp;ucGetCommandReplyRead[0],
                                                                                GETREPLYREADSIZE, iAdapterIndex, iDisplayIndex);

  *(ulMaxVal) = (ucGetCommandReplyRead[GETRP_MAXHIGH_OFFSET] &lt;&lt; 8 |ucGetCommandReplyRead[GETRP_MAXLOW_OFFSET]);
  *(ulCurVal) = (ucGetCommandReplyRead[GETRP_CURHIGH_OFFSET] &lt;&lt; 8 |ucGetCommandReplyRead[GETRP_CURLOW_OFFSET]);
}


<span class="comment">//</span>
<span class="comment">// Function:</span>
<span class="comment">//  void vSetVcpCommand</span>
<span class="comment">// Purpose:</span>
<span class="comment">// Set the values from display based on which VCP code</span>
<span class="comment">// Input: UCHAR ucVcp, VCP code (CONTRAST, BRIGHTNESS, etc)</span>
<span class="comment">//       int ulVal, which value to set</span>
<span class="comment">//       int iDisplayIndex, display index</span>
<span class="comment">// Output: VOID</span>
<span class="comment">//</span>
<span class="keywordtype">void</span> vSetVcpCommand(UCHAR ucVcp, UINT ulVal, <span class="keywordtype">int</span> iAdapterIndex, <span class="keywordtype">int</span> iDisplayIndex)
{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> chk=0;
  <span class="keywordtype">int</span> ADL_Err = <a class="code" href="group__define__adl__results.html#g917345ca58ec6b4d7c73865fdb611fd7" title="Generic Error. Most likely one or more of the Escape calls to the driver failed!">ADL_ERR</a>;

  ucSetCommandWrite[SET_VCPCODE_OFFSET] = ucVcp;
  ucSetCommandWrite[SET_LOW_OFFSET] = (char)(ulVal &amp; 0x0ff);
  ucSetCommandWrite[SET_HIGH_OFFSET] = (char)((ulVal&gt;&gt;8) &amp; 0x0ff);

  <span class="keywordflow">for</span>( i = 0; i &lt; SET_CHK_OFFSET; i++)
    chk=chk ^ ucSetCommandWrite[i];

  ucSetCommandWrite[SET_CHK_OFFSET] = chk;
  ADL_Err = vWriteI2c( (<span class="keywordtype">char</span>*)&amp;ucSetCommandWrite[0], SETWRITESIZE, iAdapterIndex, iDisplayIndex);
  Sleep(50);
}


<span class="comment">// Function:</span>
<span class="comment">//      void vWriteI2c</span>
<span class="comment">// Purpose:</span>
<span class="comment">// Write to and read from an i2s address </span>
<span class="comment">// Input: char * lpucSendMsgBuf                 Data to write</span>
<span class="comment">//                      int iSendMsgLen                                 Length of data</span>
<span class="comment">//                      int iAdapterIndex, int iDisplayIndex</span>
<span class="comment">//      Output: result code</span>
<span class="comment">//</span>
<span class="keywordtype">int</span> vWriteI2c(<span class="keywordtype">char</span> * lpucSendMsgBuf, <span class="keywordtype">int</span> iSendMsgLen, <span class="keywordtype">int</span> iAdapterIndex, <span class="keywordtype">int</span> iDisplayIndex)
{
    <span class="keywordtype">int</span> iRev = 0;
        <span class="keywordflow">return</span> adlprocs.ADL_Display_DDCBlockAccess_Get( iAdapterIndex, iDisplayIndex, NULL, NULL, iSendMsgLen, lpucSendMsgBuf, &amp;iRev, NULL);
}

<span class="comment">// Function:</span>
<span class="comment">// void vWriteAndReadI2c</span>
<span class="comment">// Purpose:</span>
<span class="comment">// Write to and read from an i2s address </span>
<span class="comment">// Input: char * lpucSendMsgBuf                 Data to write</span>
<span class="comment">//                      int iSendMsgLen                                 Length of data</span>
<span class="comment">//                      char * lpucRecvMsgBuf                   Read buffer</span>
<span class="comment">//                      int iRecvMsgLen                                         Read buffer size</span>
<span class="comment">//                      int iAdapterIndex, int iDisplayIndex</span>
<span class="comment">//      Output: result code</span>
<span class="comment">//</span>
<span class="keywordtype">int</span> vWriteAndReadI2c(<span class="keywordtype">char</span> * lpucSendMsgBuf, <span class="keywordtype">int</span> iSendMsgLen, <span class="keywordtype">char</span> * lpucRecvMsgBuf, <span class="keywordtype">int</span> iRecvMsgLen,  <span class="keywordtype">int</span> iAdapterIndex, <span class="keywordtype">int</span> iDisplayIndex)
{
        <span class="keywordflow">return</span> adlprocs.ADL_Display_DDCBlockAccess_Get( iAdapterIndex, iDisplayIndex, NULL, NULL,
                                                                                                                                                        iSendMsgLen, lpucSendMsgBuf, &amp;iRecvMsgLen, lpucRecvMsgBuf);
}

<span class="comment">//******************************</span>
<span class="comment">// CDDCBlockAccessDlg dialog</span>
<span class="comment">//******************************</span>
CDDCBlockAccessDlg::CDDCBlockAccessDlg(CWnd* pParent <span class="comment">/*=NULL*/</span>)
        : CDialog(CDDCBlockAccessDlg::IDD, pParent)
{
        m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);
}

<span class="keywordtype">void</span> CDDCBlockAccessDlg::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
  DDX_Control(pDX, IDC_COMBO_VCPCODE, cb_VCPCode);
  DDX_Control(pDX, IDC_COMBO_DISPLAYINDEX, m_indexList);
  DDX_Control(pDX, IDC_COMBO_DRIVERINDEX, m_deviceList);
}

BEGIN_MESSAGE_MAP(CDDCBlockAccessDlg, CDialog)
        ON_WM_PAINT()
        ON_WM_QUERYDRAGICON()
        <span class="comment">//}}AFX_MSG_MAP</span>
  ON_BN_CLICKED(IDOK, &amp;CDDCBlockAccessDlg::OnBnClickedOk)
  ON_BN_CLICKED(IDC_BUTTON_GET, &amp;CDDCBlockAccessDlg::OnBnClickedButtonGet)
  ON_BN_CLICKED(IDC_BUTTON_SET, &amp;CDDCBlockAccessDlg::OnBnClickedButtonSet)
  ON_WM_DESTROY()
  ON_CBN_SELCHANGE(IDC_COMBO_VCPCODE, &amp;CDDCBlockAccessDlg::OnCbnSelchangeComboVcpcode)
  ON_CBN_SELCHANGE(IDC_COMBO_DISPLAYINDEX, &amp;CDDCBlockAccessDlg::OnCbnSelchangeComboDisplayindex)
  ON_CBN_SELCHANGE(IDC_COMBO_DRIVERINDEX, &amp;CDDCBlockAccessDlg::OnCbnSelchangeComboDriverindex)
END_MESSAGE_MAP()


<span class="comment">// CDDCBlockAccessDlg message handlers</span>

BOOL CDDCBlockAccessDlg::OnInitDialog()
{
        CDialog::OnInitDialog();

        <span class="comment">// Set the icon for this dialog.  The framework does this automatically</span>
        <span class="comment">// when the application's main window is not a dialog</span>
        SetIcon(m_hIcon, TRUE);                 <span class="comment">// Set big icon</span>
        SetIcon(m_hIcon, FALSE);                <span class="comment">// Set small icon</span>

<span class="comment">// Initialize ADL</span>
  <span class="keywordflow">if</span> ( !InitADL() )
                exit (1);

        memset( &amp;aAllConnectedDisplays[0], 0, <span class="keyword">sizeof</span> (aAllConnectedDisplays) );
  m_deviceList.ResetContent();
  CString sDriverNames[MAX_NUM_DISPLAY_DEVICES];        <span class="comment">//String array of all ATI device names (aligned with aAllConnectedDisplays)</span>

  <span class="comment">// Enumerate all AMD desktops</span>
  <span class="keywordtype">int</span> numberOfATIDevices = iInitDisplayNames( sDriverNames );

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; MAX_NUM_DISPLAY_DEVICES ; i++)
  {
    <span class="keywordflow">if</span> (sDriverNames[i].GetLength( ) != 0 )
    {
      <span class="comment">//Add the name to the Driver ID combo box (AddString)</span>
      <span class="comment">//At the same time set that entry to have i (SetItemData)</span>
      <span class="comment">//i will be saved as the driver ID corresponding to this device name</span>
      m_deviceList.SetItemData (m_deviceList.AddString(sDriverNames[i]), i);

      <span class="comment">// No need to call ATIDL_GetConnectedDisplays(i, &amp;aAllConnectedDisplays[i])  (Very expensive call).</span>
          <span class="comment">// The connected and mapped displays are already recorded.</span>
    }
  }
  m_deviceList.SetCurSel(0);

  <span class="comment">//Refresh the display index for the first ATI device</span>
  RefreshDisplayIndices ();

  <span class="comment">// Init VCP combo box</span>
  cb_VCPCode.AddString(_T(<span class="stringliteral">"Luminance"</span>));
  cb_VCPCode.AddString(_T(<span class="stringliteral">"Contrast"</span>));
  cb_VCPCode.AddString(_T(<span class="stringliteral">"Color Temperature"</span>));
  cb_VCPCode.AddString(_T(<span class="stringliteral">"Get Capabilities (Fixed)"</span>));
  cb_VCPCode.AddString(_T(<span class="stringliteral">"Get Capabilities (Variable)"</span>));
  cb_VCPCode.SetCurSel(0);

        <span class="keywordflow">return</span> TRUE;  <span class="comment">// return TRUE  unless you set the focus to a control</span>
}

<span class="comment">// If you add a minimize button to your dialog, you will need the code below</span>
<span class="comment">//  to draw the icon.  For MFC applications using the document/view model,</span>
<span class="comment">//  this is automatically done for you by the framework.</span>

<span class="keywordtype">void</span> CDDCBlockAccessDlg::OnPaint()
{
        <span class="keywordflow">if</span> (IsIconic())
        {
                CPaintDC dc(<span class="keyword">this</span>); <span class="comment">// device context for painting</span>

                SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0);

                <span class="comment">// Center icon in client rectangle</span>
                <span class="keywordtype">int</span> cxIcon = GetSystemMetrics(SM_CXICON);
                <span class="keywordtype">int</span> cyIcon = GetSystemMetrics(SM_CYICON);
                CRect rect;
                GetClientRect(&amp;rect);
                <span class="keywordtype">int</span> x = (rect.Width() - cxIcon + 1) / 2;
                <span class="keywordtype">int</span> y = (rect.Height() - cyIcon + 1) / 2;

                <span class="comment">// Draw the icon</span>
                dc.DrawIcon(x, y, m_hIcon);
        }
        <span class="keywordflow">else</span>
        {
                CDialog::OnPaint();
        }
}

<span class="comment">//This function is to refresh the Display index combo box</span>
<span class="keywordtype">void</span> CDDCBlockAccessDlg::RefreshDisplayIndices ()
{
  <span class="keywordtype">int</span> iAdapterIndex = (int) m_deviceList.GetItemData ( m_deviceList.GetCurSel() );
  <span class="keywordtype">int</span> ulDisplaysConnected = aAllConnectedDisplays[iAdapterIndex];

  <span class="comment">//Clear the list</span>
  m_indexList.ResetContent();

  <span class="comment">// ulDisplayIndices is a bit vector of connected displays</span>
  <span class="comment">// for example, if ulDisplaysConnected == 0x9, i.e binary 1001, this means</span>
  <span class="comment">// you have two display devices connected - one has index 0, and another has index 3</span>
  <span class="comment">// another example: ulDisplaysConnected = 0x7, i.e. binary 0111, means</span>
  <span class="comment">// you have 3 displays connected - one has index 0, another has index 1, and another has index 2  </span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0 ; ulDisplaysConnected != 0 ; j++ )
  {
    <span class="keywordflow">if</span> (ulDisplaysConnected &amp; 0x1)
    {
      TCHAR ucTemp[5];
      wsprintf(ucTemp,_T(<span class="stringliteral">"%d"</span>),j);

      <span class="comment">//Add the display index to the combo box (AddString)</span>
      <span class="comment">//At the same time save the j into that entry (SetItemData)</span>
      <span class="comment">//j will be the display index corresponding to this entry</span>
      m_indexList.SetItemData (m_indexList.AddString(ucTemp), j);
    }
    ulDisplaysConnected = ulDisplaysConnected&gt;&gt;1;
  }
  
  m_indexList.SetCurSel(0);
  <span class="keywordtype">int</span> iDisplayIndex = (int)m_indexList.GetItemData ( m_indexList.GetCurSel() );

<span class="comment">//  SetDlgItemText(IDC_EDIT_MONNAME, MonitorNames[ iDisplayIndex ] );</span>
  std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; conv;
  std::wstring wideAdapterName = conv.from_bytes(lpAdapterInfo[iAdapterIndex].strAdapterName);
  std::wstring wideDisplayName = conv.from_bytes(lpAdapterInfo[iAdapterIndex].strDisplayName);
  SetDlgItemText(IDC_EDIT_ANAME, wideAdapterName.c_str());
  SetDlgItemText(IDC_EDIT_DNAME, wideDisplayName.c_str());

  <span class="comment">// Read the EDID of the first display</span>
  OnCbnSelchangeComboDisplayindex();
}

<span class="comment">// The system calls this function to obtain the cursor to display while the user drags</span>
<span class="comment">//  the minimized window.</span>
HCURSOR CDDCBlockAccessDlg::OnQueryDragIcon()
{
        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>HCURSOR<span class="keyword">&gt;</span>(m_hIcon);
}

<span class="keywordtype">void</span> CDDCBlockAccessDlg::OnBnClickedOk()
{
  OnOK();
}

<span class="keywordtype">void</span> CDDCBlockAccessDlg::OnBnClickedButtonGet()
{
  UINT ulMax=0, ulCur=0;
  TCHAR ucBuffer [16];
  <span class="keywordtype">int</span> iAdapterIndex = (int) m_deviceList.GetItemData ( m_deviceList.GetCurSel() );
  <span class="keywordtype">int</span> iDisplayIndex = (int) m_indexList.GetItemData ( m_indexList.GetCurSel() );

  <span class="keywordflow">if</span> (ucGlobalVcp == VCP_CODE_CAPABILITIES || ucGlobalVcp == VCP_CODE_CAPABILITIES_NEW)
  {
    <span class="keywordflow">if</span> (vGetCapabilitiesCommand(ucGlobalVcp, iAdapterIndex, iDisplayIndex))
    {
      SetDlgItemText(IDC_EDIT_MAX,_T(<span class="stringliteral">"PASS"</span>));
      SetDlgItemText(IDC_EDIT_CURRENT,_T(<span class="stringliteral">"PASS"</span>));
    }
    <span class="keywordflow">else</span>
    {
      SetDlgItemText(IDC_EDIT_MAX,_T(<span class="stringliteral">"FAIL"</span>));
      SetDlgItemText(IDC_EDIT_CURRENT,_T(<span class="stringliteral">"FAIL"</span>));
    }
  }
  <span class="keywordflow">else</span>
  {
    vGetVcpCommand( ucGlobalVcp, &amp;ulMax, &amp;ulCur, iAdapterIndex, iDisplayIndex );

    ulMax &amp;= 0x0ffff;
    ulCur &amp;= 0x0ffff;
    wsprintf(ucBuffer,_T(<span class="stringliteral">"0x%x"</span>),ulMax);
    SetDlgItemText(IDC_EDIT_MAX,ucBuffer);
    wsprintf(ucBuffer,_T(<span class="stringliteral">"0x%x"</span>),ulCur);
    SetDlgItemText(IDC_EDIT_CURRENT,ucBuffer);
  }
}

<span class="keywordtype">void</span> CDDCBlockAccessDlg::OnBnClickedButtonSet()
{
  UINT ulCur=0;
  TCHAR ucBuffer[255];
  <span class="keywordtype">int</span> iAdapterIndex = (int) m_deviceList.GetItemData ( m_deviceList.GetCurSel() );
  <span class="keywordtype">int</span> iDisplayIndex = (int) m_indexList.GetItemData ( m_indexList.GetCurSel() );

  <span class="keywordflow">if</span>( GetDlgItemText(IDC_EDIT_CURRENT,ucBuffer,10) &gt; 0 )
  {
      <span class="keywordflow">if</span> (_stscanf_s(ucBuffer, _T(<span class="stringliteral">"%x"</span>), &amp;(ulCur)) &gt; 0)
    {
      vSetVcpCommand(ucGlobalVcp,ulCur, iAdapterIndex, iDisplayIndex);
    }
  }
}

<span class="keywordtype">void</span> CDDCBlockAccessDlg::OnDestroy()
{
  CDialog::OnDestroy();
  FreeADL();
}

<span class="keywordtype">void</span> CDDCBlockAccessDlg::OnCbnSelchangeComboVcpcode()
{
  <span class="keywordtype">int</span> sel = cb_VCPCode.GetCurSel();
  GetDlgItem(IDC_BUTTON_SET)-&gt;EnableWindow(TRUE);

  <span class="comment">/***********************************</span>
<span class="comment">  / 0 - "Luminance"</span>
<span class="comment">  / 1 - "Contrast"</span>
<span class="comment">  / 2 - "Color Temperature"</span>
<span class="comment">  / 3 - "Get Capabilities (Fixed)"</span>
<span class="comment">  / 4 - "Get Capabilities (Variable)"</span>
<span class="comment">  /***********************************/</span>
  <span class="keywordflow">switch</span> (sel)
  {
  <span class="keywordflow">case</span> 0:
    ucGlobalVcp = VCP_CODE_BRIGHTNESS;
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> 1: <span class="comment">// contrast</span>
    ucGlobalVcp = VCP_CODE_CONTRAST;
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> 2: <span class="comment">// color temperature</span>
    ucGlobalVcp = VCP_CODE_COLORTEMP;
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> 3: <span class="comment">// get capabilities 38 read</span>
    ucGlobalVcp = VCP_CODE_CAPABILITIES;
    GetDlgItem(IDC_BUTTON_SET)-&gt;EnableWindow(FALSE);
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> 4: <span class="comment">// get capabilities new</span>
    ucGlobalVcp = VCP_CODE_CAPABILITIES_NEW;
    GetDlgItem(IDC_BUTTON_SET)-&gt;EnableWindow(FALSE);
    <span class="keywordflow">break</span>;
  }
}

<span class="keywordtype">void</span> CDDCBlockAccessDlg::OnCbnSelchangeComboDisplayindex()
{
  TCHAR hexBuffer[1000*2];
  TCHAR tBuffer[1000*2];
  TCHAR cTemp[4*2];
  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ucSymbol;
  <span class="keywordtype">int</span> iAdapterIndex = (int) m_deviceList.GetItemData ( m_deviceList.GetCurSel() );
  <span class="keywordtype">int</span> iDisplayIndex = (int) m_indexList.GetItemData ( m_indexList.GetCurSel() );
  
  <span class="comment">//Setup structures for the ADL call</span>
  <a name="_a10"></a><a class="code" href="structADLDisplayEDIDData.html" title="Structure containing information about EDID data.">ADLDisplayEDIDData</a>  aBlockOutput;
  ZeroMemory(&amp;aBlockOutput, <span class="keyword">sizeof</span>(<a class="code" href="structADLDisplayEDIDData.html" title="Structure containing information about EDID data.">ADLDisplayEDIDData</a>));
  aBlockOutput.<a name="a11"></a><a class="code" href="structADLDisplayEDIDData.html#cf14699a5a7d4c638a390e66d487e67f" title="Size of the structure.">iSize</a>   = <span class="keyword">sizeof</span>(<a class="code" href="structADLDisplayEDIDData.html" title="Structure containing information about EDID data.">ADLDisplayEDIDData</a>);
  aBlockOutput.<a name="a12"></a><a class="code" href="structADLDisplayEDIDData.html#298363c49f53fad71f0b49642b7c3ef3" title="0, 1 or 2. If set to 3 or above an error ADL_ERR_INVALID_PARAM is generated">iBlockIndex</a> = 0; <span class="comment">//First block</span>
  
  std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; conv;
  std::wstring wideChar = conv.from_bytes(MonitorNames[iDisplayIndex]);
  SetDlgItemText(IDC_EDIT_MONNAME, wideChar.c_str());

  <span class="comment">//Call ADL to get the EDID</span>
  adlprocs.ADL_Display_EdidData_Get(iAdapterIndex, iDisplayIndex, &amp;aBlockOutput);

  <span class="comment">//Printout</span>
  _tcscpy_s(hexBuffer, _T(<span class="stringliteral">""</span>));
  _tcscpy_s(tBuffer, _T(<span class="stringliteral">""</span>));
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; aBlockOutput.<a name="a13"></a><a class="code" href="structADLDisplayEDIDData.html#29313b35e72456a2a99bf7acb202dc2a" title="Size of cEDIDData. Set by ADL_Display_EdidData_Get() upon return.">iEDIDSize</a> ; i++)
  {
    <span class="comment">//Newline every 8 bytes</span>
    <span class="keywordflow">if</span> (i != 0 &amp;&amp; i% 8 == 0)
        {
        _tcscat_s(hexBuffer, _T(<span class="stringliteral">"\r\n"</span>));
        _tcscat_s(tBuffer, _T(<span class="stringliteral">"\r\n"</span>));
        }

    <span class="comment">//add the byte to the buffer string</span>
        ucSymbol = (<span class="keywordtype">unsigned</span> char)aBlockOutput.<a name="a14"></a><a class="code" href="structADLDisplayEDIDData.html#83e30fa7d24cd49a601ec8e7a7d5acd5" title="EDID data.">cEDIDData</a>[i];
    wsprintf( cTemp,_T(<span class="stringliteral">" %.2x"</span>), ucSymbol );
    _tcscat_s(hexBuffer, cTemp);

    <span class="keywordflow">if</span> ( ucSymbol &lt; 0x20 )                      <span class="comment">// Mask control characters</span>
                ucSymbol |= 0x20;

    wsprintf(cTemp, _T(<span class="stringliteral">" %c"</span>), ucSymbol);
    _tcscat_s(tBuffer, cTemp);
  }

  <span class="comment">//Print to Edit box  </span>
  SetDlgItemText(IDC_EDIT_RAWEDID, hexBuffer);
  SetDlgItemText(IDC_EDIT_TEXTEDID, tBuffer);
}

<span class="keywordtype">void</span> CDDCBlockAccessDlg::OnCbnSelchangeComboDriverindex()
{
  RefreshDisplayIndices ();
}


<span class="comment">// Function:</span>
<span class="comment">// void InitADL</span>
<span class="comment">// Purpose:</span>
<span class="comment">// Initialize ADL functions</span>
<span class="comment">// Input: NONE</span>
<span class="comment">// Output: bool, Function successful or not</span>
<span class="keywordtype">bool</span> InitADL()
{
        <span class="keywordtype">int</span>     ADL_Err = <a class="code" href="group__define__adl__results.html#g917345ca58ec6b4d7c73865fdb611fd7" title="Generic Error. Most likely one or more of the Escape calls to the driver failed!">ADL_ERR</a>;
  <span class="keywordflow">if</span> (!adlprocs.hModule)
  {
    adlprocs.hModule = LoadLibrary(_T(<span class="stringliteral">"atiadlxx.dll"</span>));
    <span class="comment">// A 32 bit calling application on 64 bit OS will fail to LoadLIbrary.</span>
    <span class="comment">// Try to load the 32 bit library (atiadlxy.dll) instead</span>
    <span class="keywordflow">if</span> (adlprocs.hModule == NULL)
      adlprocs.hModule = LoadLibrary(_T(<span class="stringliteral">"atiadlxy.dll"</span>));

    <span class="keywordflow">if</span>(adlprocs.hModule)
    {
      adlprocs.ADL_Main_Control_Create       = (ADL_MAIN_CONTROL_CREATE) GetProcAddress(adlprocs.hModule, <span class="stringliteral">"ADL_Main_Control_Create"</span>);
      adlprocs.ADL_Main_Control_Destroy      = (ADL_MAIN_CONTROL_DESTROY) GetProcAddress(adlprocs.hModule, <span class="stringliteral">"ADL_Main_Control_Destroy"</span>);
      adlprocs.ADL_Adapter_NumberOfAdapters_Get   = (ADL_ADAPTER_NUMBEROFADAPTERS_GET) GetProcAddress(adlprocs.hModule, <span class="stringliteral">"ADL_Adapter_NumberOfAdapters_Get"</span>);
      adlprocs.ADL_Adapter_AdapterInfo_Get   = (ADL_ADAPTER_ADAPTERINFO_GET) GetProcAddress(adlprocs.hModule, <span class="stringliteral">"ADL_Adapter_AdapterInfo_Get"</span>);
      adlprocs.ADL_Display_DisplayInfo_Get   = (ADL_DISPLAY_DISPLAYINFO_GET) GetProcAddress(adlprocs.hModule, <span class="stringliteral">"ADL_Display_DisplayInfo_Get"</span>);
      adlprocs.ADL_Display_DDCBlockAccess_Get   = (ADL_DISPLAY_DDCBLOCKACCESSGET) GetProcAddress(adlprocs.hModule, <span class="stringliteral">"ADL_Display_DDCBlockAccess_Get"</span>);
      adlprocs.ADL_Display_EdidData_Get   = (ADL_DISPLAY_EDIDDATA_GET) GetProcAddress(adlprocs.hModule, <span class="stringliteral">"ADL_Display_EdidData_Get"</span>);
    }
    
    <span class="keywordflow">if</span>(adlprocs.hModule == NULL              ||
                adlprocs.ADL_Main_Control_Create == NULL ||
                adlprocs.ADL_Main_Control_Destroy == NULL ||
                adlprocs.ADL_Adapter_NumberOfAdapters_Get == NULL ||
                adlprocs.ADL_Adapter_AdapterInfo_Get == NULL ||
                adlprocs.ADL_Display_DisplayInfo_Get == NULL ||
                adlprocs.ADL_Display_DDCBlockAccess_Get   == NULL || 
                adlprocs.ADL_Display_EdidData_Get   == NULL ) 
    {
      AfxMessageBox(_T(<span class="stringliteral">"Error: ADL initialization failed! This app will NOT work!"</span>), MB_OK, 0);
      <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
        <span class="comment">// Initialize ADL with second parameter = 1, which means: Get the info for only currently active adapters!</span>
    ADL_Err = adlprocs.ADL_Main_Control_Create (ADL_Main_Memory_Alloc, 1);

  }
  <span class="keywordflow">return</span> (<a name="a15"></a><a class="code" href="group__define__adl__results.html#g29dfbfcc4a3b9092febd107586668a75" title="ADL function completed successfully.">ADL_OK</a> == ADL_Err) ?  <span class="keyword">true</span> : <span class="keyword">false</span>;
          
}

<span class="comment">// Function:</span>
<span class="comment">// void FreeADL</span>
<span class="comment">// Purpose:</span>
<span class="comment">// free the ADL Module</span>
<span class="comment">// Input: NONE</span>
<span class="comment">// Output: VOID</span>
<span class="keywordtype">void</span> FreeADL()
{

  ADL_Main_Memory_Free ( (<span class="keywordtype">void</span> **)&amp;lpAdapterInfo );
  ADL_Main_Memory_Free ( (<span class="keywordtype">void</span> **)&amp;lpAdlDisplayInfo );

  adlprocs.ADL_Main_Control_Destroy ();
  FreeLibrary (adlprocs.hModule);
  adlprocs.hModule = NULL;
}

</pre></div> </div>
<hr size="1"><div  style="text-align: right;"><small>Copyright &copy 2009-2016 Advanced Micro Devices, Inc. All rights reserved.&nbsp;
<a href="http://developer.amd.com"><img src="53863A_AMD_E_Blk_RGB.PNG" title="developer.amd.com" align="middle" border="0" height="10px"></a></small></div>
</body>
</html>
